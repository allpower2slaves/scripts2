#!/bin/sh
# a simple utility to recursive cat files in a dir
# by default, it should print out headers (i think)
# must be posix-compatible(!!!) NOTE: this thing can also use realpath, which is a part of GNU coreutils and BSD utils so i guess im clear

# positional variables (or whatever you can call em)
# DO NOT INDEX by '.' symbol -- find will show it no matter what options i use

# TODO:
# option to disable command output (aka no 'cat' in front of the filename)
# option to disable filename output completely
# option to just list the indexed files (btw i think -c '' construction is ok
# just make the parser because if its empty as is it will try to launch every
# indexed file which is bad and insecure and whatever)
# option to filter the file output via something

# todo secondary
# option to disable color (probably create a new color variable and make stdout
# check much earlier then) (i think theres no need for moving stdout after
# having a second thought)
# option to set the custom delimiter (its a very hackable solution because the
# end user could use $rcat_* variables with them)

# notes
# thanks to the modular design of this program (all functions are indepent of
# each other and only use shared global main level variables), its easy to add
# new features. also it seems that the indexer function doesnt even need any
# tweaking

rcat_index="" # variable for dir\file setting

# varbiables for options
rcat_insert_newline="0"
rcat_insert_filename="0"
# variable for separator
rcat_quiet="0"
rcat_sep="\n" # maybe use it with printf idk

# advanced
rcat_cat_variables=""
rcat_ignore_git="1" # ignore .git directory :)
rcat_ignore_dot="1" # ignore all files starting with .
rcat_ignore_binary="1" # do not cat binary files
rcat_realpath="0" # if 1, print out realpath

rcat_cat_executable="cat"

find_options="" # options for find thing
find_after_pipe=""

while :; do
	case $1 in
		-h | --help)
			greeter_help
			exit 0;;
		-v | --verbose) 
			set -o xtrace # TODO: posixfy
			shift
			;;
		-q | --quiet) # disable separator newline and newfile
			shift
			;;
		-a) # show files starting with dot, excluding git
			rcat_ignore_dot="0"
			shift
			;;
		-A | --all) # show everything, including .git
			rcat_ignore_dot="0"
			rcat_ignore_git="0"
			shift
			;;
		-b | --binary) # also cat binary files
			rcat_ignore_binary="0"
			shift
			;;
		-R | --realpath) # index realpath filenames
			rcat_realpath="1"
			shift
			;;
		# todo: make grep-like thing maybe(?)
		# todo: make the thing use * maybe
		-e | --exclude) # exclude pattern
			find_after_pipe="${find_after_pipe} | grep -v '$2'"
			shift
			shift
			;;
		-c | --command) # execute command on files (default:cat)
			rcat_cat_executable="$2"
			shift
			shift
			;;
		--) # end of all options
			shift
			break
			;;
		-*) # invalid option
			printf >&2 "ERROR: Invalid flag '%s'\n\n" "$1"
			greeter_help
			exit 1
			;;
		*) # when there are no more options
			if [ -n "$1" ]; then
				rcat_index="$1"
			else
				rcat_index="."
			fi
			break
	esac
done

get_files(){ 
# function to parse all uhh

# NOTE: i changed it to `find | grep` because `-not` is absent in POSIX and busybox

# todo: (maybe) move it to option parser because itll be more compact
# TODO: please uhh reevaluate grep syntax

if [ $rcat_ignore_dot -eq 1 ]; then
	find_after_pipe="${find_after_pipe} | grep -v -F '/.'"
fi
if [ $rcat_ignore_git -eq 1 ]; then
	find_after_pipe="${find_after_pipe} | grep -v -F '.git/'"
fi

# todo: maybe add `-t` trace mode option to xtrace with -v
if [ $rcat_realpath -eq 1 ]; then
	find_after_pipe="${find_after_pipe} | xargs realpath"
fi

# return the thing
eval "find "$1" $find_options $find_after_pipe 2>/dev/null" 2>/dev/null
return 0
}

check_files(){
# function is basically "is this file a textfile
# do i need return here? idk

if [ $rcat_ignore_binary -ne 0 ]; then
POSIXLY_CORRECT=1 file "$1" | grep -q ':.*text' && return 0
else
	return 0
fi
}

print_file(){
if [ $rcat_quiet -eq 0 ]; then
	if [ -t 1 ]; then # if stdout is terminal
		printf "%b" "\033[33;1m$rcat_cat_executable "$1"\033[0m\n"
		# colored variant
	else
		printf "%b" "$rcat_cat_executable "$1"\n"
	fi
fi
eval ""$rcat_cat_executable" "$1""
}

# debug
#echo $find_after_pipe
#echo $rcat_cat_executable

#get_files "$rcat_index" | while IFS= read -r filename; do check_files "$filename" && echo "$filename" ; done

get_files "$rcat_index" | while IFS= read -r filename; do check_files "$filename" && print_file "$filename"; done
